<!DOCTYPE html>
<html>
<head>
  <title>Javascript Tetris</title>
  <style>
  
	#canvas   { display: inline-block; vertical-align: top; box-shadow: 10px 10px 10px #999; border: 2px solid #333; }
	@media screen and (min-width: 0px) and (min-height: 0px)  { #canvas { width: 100px; height: 200px; } } /* 10px chunks */
	@media screen and (min-width: 300px) and (min-height: 500px)  { #canvas { width: 200px; height: 400px; } } /* 20px chunks */
	@media screen and (min-width: 400px) and (min-height: 700px)  { #canvas { width: 300px; height: 600px; } } /* 30px chunks */
	@media screen and (min-width: 500px) and (min-height: 900px)  { #canvas { width: 400px; height: 800px; } } /* 40px chunks */

   
  </style>
</head>

<body>
	<canvas id="canvas" width="400" height="800" >
	Your browser does not support the HTML5 canvas tag.
	</canvas>
  
	<script>
	
	////////////////////////////////////////////////////
	// Animation API
	////////////////////////////////////////////////////
	window.requestAnimFrame = (function(){
		return  window.requestAnimationFrame       || 
				window.webkitRequestAnimationFrame || 
				window.mozRequestAnimationFrame    || 
				window.oRequestAnimationFrame      || 
				window.msRequestAnimationFrame     || 
				function(/* function */ callback, /* DOMElement */ element){
				window.setTimeout(callback, 1000 / 60);
				};
    })();
	
	////////////////////////////////////////////////////
	// TETRIS PIECES 
	////////////////////////////////////////////////////
	var s = { blocks : [0xC600, 0x4C80, 0xC600, 0x4C80], colour : 'red'};
	var z = { blocks : [0x6C00, 0x8C40, 0x6C00, 0x8C40], colour : 'orange'};
	var l = { blocks : [0xC880, 0x08E0, 0x2260, 0xE200], colour : 'green'};
	var j = { blocks : [0x02E0, 0x6220, 0xE800, 0x88C0], colour : 'purple'};
	var t = { blocks : [0x4C40, 0x0E40, 0x4640, 0x4E00], colour : 'yellow'};
	var i = { blocks : [0x0F00, 0x4444, 0x00F0, 0x2222], colour : 'violet'};
	var o = { blocks : [0x0CC0, 0x0CC0, 0x0CC0, 0x0CC0], colour : 'blue'};
	
	////////////////////////////////////////////////////
	// INIT 
	////////////////////////////////////////////////////
	var canvas = document.getElementById('canvas');
	var ctx = canvas.getContext('2d');
	var nx = 10; 
	var ny = 20;
	var hy = canvas.height;
	var hx = canvas.width;
	var height = hy / ny;
	var width = hx / nx;

	////////////////////////////////////////////////////
	// GAME VARIABLES
	////////////////////////////////////////////////////
	var GAMESTATE = {STARTSCREEN:0, GAMEON:1, GAMEOVER:2};
	var map; //[y][x]
	map = new Array(ny);
	for(var y=0; y < ny ; y++) {
		initRow(map ,y , nx);
	}
	var locX, locY, current, rotation, gameState, ClearedLines, Score;
	
	startScreen();

	////////////////////////////////////////////////////
	// EXCEPTIONS 
	////////////////////////////////////////////////////
	var KEY  = { ESC: 27, SPACE: 32, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40 , ENTER: 13, SHIFT: 16, DEL:46, END:35};
	
	function addExceptions() {
		document.addEventListener('keydown', keydown, false);
		window.addEventListener('resize', resize, false);
	}
	
	function keydown(event) {
		if(gameState == GAMESTATE.GAMEON) {
			if(event.keyCode == KEY.LEFT ) {
				moveLeft();
			}
			else if(event.keyCode == KEY.RIGHT ) {
				moveRight();
			}
			else if(event.keyCode == KEY.UP ) {
				rotateLeft();
			}
			else if(event.keyCode == KEY.DOWN ) {
				if(!moveDown()) {
					checkLines();
				}
			}
			else if(event.keyCode == KEY.SPACE ) {
				while(moveDown());
				checkLines();
			}
			else if(event.keyCode == KEY.END ) {
				gameOver();
			}
		}
		
		if(event.keyCode == KEY.DEL ) {
			newGame();
		}	
	}
	
	function resize(event){
		drawMap(ctx,nx,ny,map);
	}
			
	////////////////////////////////////////////////////
	// GAME ACTIONS 
	////////////////////////////////////////////////////	
	function moveLeft() {
		takeBlockFromMap(map, current.blocks[rotation], locY, locX, current.colour);
		if(checkBlockOnMap(map, current.blocks[rotation], locY, locX - 1)) {
			locX--;
		}
		putBlockOnMap(map, current.blocks[rotation], locY, locX, current.colour);
	}
		
	function moveRight() {
		takeBlockFromMap(map, current.blocks[rotation], locY, locX, current.colour);
		if(checkBlockOnMap(map, current.blocks[rotation], locY, locX + 1)) {
			locX++;
		}
		putBlockOnMap(map, current.blocks[rotation], locY, locX, current.colour);	
	}
	
	function moveDown() {
		var success =  false;
		takeBlockFromMap(map, current.blocks[rotation], locY, locX, current.colour);
		if(checkBlockOnMap(map, current.blocks[rotation], locY - 1, locX)) {
			locY--;
			success = true;
		}
		putBlockOnMap(map, current.blocks[rotation], locY, locX, current.colour);
		return success;
	}
	
	function rotateLeft() {
		takeBlockFromMap(map, current.blocks[rotation], locY, locX, current.colour);
		var nextRotation = rotation - 1;
		if(nextRotation < 0) {
			nextRotation = 3;
		}
		if(checkBlockOnMap(map, current.blocks[nextRotation], locY, locX)) {
			rotation = nextRotation;
		}		
		putBlockOnMap(map, current.blocks[rotation], locY, locX, current.colour);
	}
	
	function rotateRight() {
		takeBlockFromMap(map, current.blocks[rotation], locY, locX, current.colour);
		var nextRotation = rotation + 1;
		if(nextRotation > 3) {
			nextRotation = 0;
		}
		if(checkBlockOnMap(map, current.blocks[nextRotation], locY, locX)) {
			rotation = nextRotation;
		}		
		putBlockOnMap(map, current.blocks[rotation], locY, locX, current.colour);
	}
	
	function checkLines() {
		for(var row = 0; row < ny; row++) {
			var removeLine = true;
			for(var column =0; column < nx; column++) {
				if(!map[row][column].occupied) {
					removeLine = false
				}
			}
			if(removeLine == true) {
				clearLine(map,ny ,row--, 1);
				ClearedLines++;
			}
		}
		newBlock();
	}
	
	function newBlock() {
		locX = 3;
		locY = 16;
		rotation = 0;	
		current =  randomizeNextPiece();
		if(checkBlockOnMap(map, current.blocks[rotation], locY, locX)) {
			putBlockOnMap(map, current.blocks[rotation], locY, locX, current.colour);
		}
		else {
			gameOver();
		}
	}
	
	function randomizeNextPiece() {
		switch(Math.floor((Math.random() * 28) + 1)) {
			case 1: case 8:  case 15: case 22: return i; break;
			case 2: case 9:  case 16: case 23: return o; break;
			case 3: case 10: case 17: case 24: return j; break;
			case 4: case 11: case 18: case 25: return l; break;
			case 5: case 12: case 19: case 26: return z; break;
			case 6: case 13: case 20: case 27: return s; break;
			case 7: case 14: case 21: case 28: return t; break;
		}
	}	
	
	function dropPiece() {
		if(!moveDown()) {
			checkLines();
			newBlock();
		}	
		if(gameState == GAMESTATE.GAMEON) {
			window.setTimeout(function(){ dropPiece() }, 1000);
		}
	}
	
	function gameOver() {
		gameState = GAMESTATE.GAMEOVER;
	}
	
	function newGame() {
		ClearedLines = 0;
		Score = 0;
		clearMap(map, nx, ny);
		newBlock();
		if(gameState != GAMESTATE.GAMEON) {
			gameState = GAMESTATE.GAMEON;
			dropPiece();
		}
	}
	
	function startScreen() {
		addExceptions();
		animate();
		gameState = GAMESTATE.STARTSCREEN;
	}
	
	////////////////////////////////////////////////////
	// MAPPING 
	////////////////////////////////////////////////////
	function initRow(map ,row , nx) {
		map[row] = new Array(nx);
		for(var column =0; column < nx; column++) {
			map[row][column] = {occupied : false, colour : 'white'};
		}
	}
				
	function clearMap(map, nx, ny) {
		clearLine(map,ny ,0, ny);
	}
	
	function clearLine(map,ny ,y, n) {
		for(var line = y; line < ny; line++) {
			if(line + n < ny) {
				map[line] = map[line+n];
			}
			else {
				initRow(map ,line , nx);
			}
		}
	}
	
	function checkBlockOnMap(map, block, y, x) {
		var row = 3, column = 0;
		for(var mask = 0x8000;  mask > 0;  mask = mask >> 1 )
		{
			if(block & mask) {
				if(y+row < 0 || y+row >= ny || x+column < 0 || x+column >= nx ) {
					return false;	
				}
				else if(map[y+row][x+column].occupied) {
					return false;	
				}				
			}			
			if(--row == -1) {
				row = 3;
				column++;
			}
		}
		return true;
	}
	
	function putBlockOnMap(map, block, y, x, colour) {
		var row = 3, column = 0;
		for(var mask = 0x8000;  mask > 0;  mask = mask >> 1 )
		{
			if(block & mask) {
				map[y+row][x+column].occupied = true;
				map[y+row][x+column].colour = colour;	
			}
			
			if(--row == -1) {
				row = 3;
				column++;
			}
		}
	}
	
	function takeBlockFromMap(map, block, y, x) {
		var row = 3, column = 0;
		for(var mask = 0x8000;  mask > 0;  mask = mask >> 1 )
		{
			if(block & mask) {
				map[y+row][x+column].occupied = false;
				map[y+row][x+column].colour = 'white';	
			}
			
			if(--row == -1) {
				row = 3;
				column++;
			}
		}
	}
	
	////////////////////////////////////////////////////
	// DISPLAY 
	////////////////////////////////////////////////////	
	function animate() {
		requestAnimFrame( animate );
		switch(gameState) {
			case GAMESTATE.STARTSCREEN:
				drawText(ctx, hy / 2, hx / 2, "TETRIS", "center", "100px impact", 'black');
			break;
			
			case GAMESTATE.GAMEON:
				drawMap(ctx, nx, ny, map);
			break;

			case GAMESTATE.GAMEOVER:
				drawText(ctx, hy / 2, hx / 2, "GAME OVER", "center", "70px impact", 'black');
				drawText(ctx, hy * ( 0.4), hx / 2, "LINES:" + ClearedLines, "center", "60px impact", 'black');
			break;
		
		}	
	}
	
	function paintGrid(ctx, nx, ny) {
		for(var row =0; row < ny; row++) {
			for(var column =0; column < nx; column++) {
				drawBox(ctx, row, column, 'white');
			}
		}
	}
	
	function drawMap(ctx, nx, ny, map) {
		ctx.clearRect(0, 0, hx, hy);
		for(var row =0; row < ny; row++) {
			for(var column =0; column < nx; column++) {
				if(map[row][column].occupied) {
					drawBox(ctx, row, column, map[row][column].colour);
				}
			}
		}
	}
	
	// (0,0) is top left.
	// i would prefer it to be bottom left
	//hence ny-1-y instead of y
	function drawBox (ctx, y, x, colour) {
		ctx.fillStyle = colour;
		ctx.fillRect(x*width, (ny-1-y)*height, width, height );
		ctx.strokeRect(x*width, (ny-1-y)*height, width, height );
	}
	
	function drawText(ctx, y, x, text, align, font, colour) {
		var saveAlign = ctx.textAlign, saveFont = ctx.font, saveColour = ctx.colour;
		ctx.textAlign = align;
		ctx.font = font;
		ctx.fillStyle = colour;
		ctx. fillText(text, x, hy - y);
		ctx.textAlign = saveAlign;
		ctx.font = saveFont;
		ctx.colour = saveColour;
	}
	
	</script>
  
</body>
</html>